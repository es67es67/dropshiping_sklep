const ErrorTracker = require('./error-tracker');
const CodeDocumenter = require('./code-documenter');
const fs = require('fs-extra');
const path = require('path');

class CodeManager {
    constructor() {
        this.errorTracker = ErrorTracker;
        this.codeDocumenter = CodeDocumenter;
        this.rulesFile = path.join(__dirname, 'code-rules.json');
        this.statsFile = path.join(__dirname, 'code-stats.json');
        this.rules = {};
        this.stats = {};
        
        this.loadRules();
        this.setupErrorHandling();
    }

    async loadRules() {
        try {
            if (await fs.pathExists(this.rulesFile)) {
                this.rules = await fs.readJson(this.rulesFile);
            }
            
            if (await fs.pathExists(this.statsFile)) {
                this.stats = await fs.readJson(this.statsFile);
            }
        } catch (error) {
            console.error('‚ùå CodeManager: B≈ÇƒÖd ≈Çadowania regu≈Ç:', error.message);
        }
    }

    setupErrorHandling() {
        // Przechwyƒá wszystkie nieobs≈Çu≈ºone b≈Çƒôdy
        process.on('uncaughtException', (error) => {
            this.handleError(error, {
                file: 'process',
                function: 'uncaughtException',
                line: 'unknown',
                module: 'system',
                user: 'system',
                action: 'uncaughtException'
            });
        });

        process.on('unhandledRejection', (reason, promise) => {
            this.handleError(reason, {
                file: 'process',
                function: 'unhandledRejection',
                line: 'unknown',
                module: 'system',
                user: 'system',
                action: 'unhandledRejection'
            });
        });
    }

    async handleError(error, context = {}) {
        // Dodaj informacje o stosie wywo≈Ça≈Ñ
        if (error.stack) {
            const stackLines = error.stack.split('\n');
            for (const line of stackLines) {
                const fileMatch = line.match(/at\s+(.+?)\s+\((.+?):(\d+):(\d+)\)/);
                if (fileMatch && !context.file) {
                    context.file = fileMatch[2];
                    context.line = fileMatch[3];
                    context.function = fileMatch[1];
                    break;
                }
            }
        }

        // Zarejestruj b≈ÇƒÖd
        const errorEntry = await this.errorTracker.trackError(error, context);
        
        // Sprawd≈∫ regu≈Çy i zastosuj automatyczne naprawy
        await this.applyAutoFixes(errorEntry);
        
        // Zaktualizuj statystyki
        this.updateStats(errorEntry);
        
        // Zapisz regu≈Çy
        await this.saveRules();
        
        return errorEntry;
    }

    async applyAutoFixes(errorEntry) {
        const category = errorEntry.category;
        const rules = this.rules[category] || {};
        
        if (rules.autoFix) {
            console.log(`üîß Pr√≥ba automatycznej naprawy b≈Çƒôdu: ${category}`);
            
            try {
                switch (category) {
                    case 'INVALID_HANDLER':
                        await this.fixInvalidHandler(errorEntry);
                        break;
                    case 'MODULE_NOT_FOUND':
                        await this.fixModuleNotFound(errorEntry);
                        break;
                    case 'SYNTAX_ERROR':
                        await this.fixSyntaxError(errorEntry);
                        break;
                    default:
                        console.log(`‚ö†Ô∏è  Brak automatycznej naprawy dla kategorii: ${category}`);
                }
            } catch (fixError) {
                console.error(`‚ùå B≈ÇƒÖd podczas automatycznej naprawy:`, fixError.message);
            }
        }
    }

    async fixInvalidHandler(errorEntry) {
        const file = errorEntry.context.file;
        const line = errorEntry.context.line;
        
        if (file && line) {
            try {
                const content = await fs.readFile(file, 'utf8');
                const lines = content.split('\n');
                
                // Sprawd≈∫ czy to jest problem z userRoutes.js
                if (file.includes('userRoutes.js')) {
                    // Dodaj walidacjƒô handlera
                    const newContent = this.addHandlerValidation(content);
                    await fs.writeFile(file, newContent);
                    
                    errorEntry.status = 'fixed';
                    errorEntry.fixHistory.push({
                        timestamp: new Date().toISOString(),
                        description: 'Dodano walidacjƒô handlera w userRoutes.js'
                    });
                    
                    console.log(`‚úÖ Naprawiono b≈ÇƒÖd INVALID_HANDLER w ${file}`);
                }
            } catch (error) {
                console.error(`‚ùå B≈ÇƒÖd naprawy INVALID_HANDLER:`, error.message);
            }
        }
    }

    async fixModuleNotFound(errorEntry) {
        const message = errorEntry.error.message;
        const moduleMatch = message.match(/Cannot find module '(.+?)'/);
        
        if (moduleMatch) {
            const moduleName = moduleMatch[1];
            console.log(`üì¶ Pr√≥ba instalacji modu≈Çu: ${moduleName}`);
            
            // Tutaj mo≈ºna dodaƒá automatycznƒÖ instalacjƒô modu≈Çu
            // npm install ${moduleName}
        }
    }

    async fixSyntaxError(errorEntry) {
        const file = errorEntry.context.file;
        const line = errorEntry.context.line;
        
        if (file && line) {
            console.log(`üîß Sprawd≈∫ sk≈Çadniƒô w ${file}:${line}`);
            // Tutaj mo≈ºna dodaƒá automatyczne sprawdzanie sk≈Çadni
        }
    }

    addHandlerValidation(content) {
        // Dodaj funkcjƒô safeRoute je≈õli nie istnieje
        if (!content.includes('function safeRoute')) {
            const safeRouteFunction = `
function safeRoute(method, path, ...handlers) {
  // Ostatni handler musi byƒá funkcjƒÖ
  const last = handlers[handlers.length - 1];
  if (typeof last === 'function') {
    router[method](path, ...handlers);
  } else {
    console.warn(\`‚ö†Ô∏è  Handler dla \${method.toUpperCase()} \${path} nie jest funkcjƒÖ! Pomijam trasƒô.\`);
  }
}

`;
            // Wstaw przed pierwszym router.get
            const insertIndex = content.indexOf('router.get');
            if (insertIndex !== -1) {
                return content.slice(0, insertIndex) + safeRouteFunction + content.slice(insertIndex);
            }
        }
        
        return content;
    }

    updateStats(errorEntry) {
        const category = errorEntry.category;
        const file = errorEntry.context.file;
        
        // Statystyki kategorii
        if (!this.stats.categories) this.stats.categories = {};
        if (!this.stats.categories[category]) {
            this.stats.categories[category] = {
                count: 0,
                firstSeen: errorEntry.timestamp,
                lastSeen: errorEntry.timestamp,
                fixedCount: 0,
                autoFixedCount: 0
            };
        }
        this.stats.categories[category].count++;
        this.stats.categories[category].lastSeen = errorEntry.timestamp;
        
        if (errorEntry.status === 'fixed') {
            this.stats.categories[category].fixedCount++;
        }
        
        // Statystyki plik√≥w
        if (!this.stats.files) this.stats.files = {};
        if (!this.stats.files[file]) {
            this.stats.files[file] = {
                count: 0,
                firstSeen: errorEntry.timestamp,
                lastSeen: errorEntry.timestamp,
                errorTypes: {}
            };
        }
        this.stats.files[file].count++;
        this.stats.files[file].lastSeen = errorEntry.timestamp;
        
        if (!this.stats.files[file].errorTypes[category]) {
            this.stats.files[file].errorTypes[category] = 0;
        }
        this.stats.files[file].errorTypes[category]++;
        
        // Statystyki og√≥lne
        if (!this.stats.general) this.stats.general = {};
        this.stats.general.totalErrors = (this.stats.general.totalErrors || 0) + 1;
        this.stats.general.lastError = errorEntry.timestamp;
        this.stats.general.autoFixedErrors = (this.stats.general.autoFixedErrors || 0) + 
            (errorEntry.status === 'fixed' ? 1 : 0);
    }

    async saveRules() {
        try {
            await fs.writeJson(this.rulesFile, this.rules, { spaces: 2 });
            await fs.writeJson(this.statsFile, this.stats, { spaces: 2 });
        } catch (error) {
            console.error('‚ùå CodeManager: B≈ÇƒÖd zapisywania regu≈Ç:', error.message);
        }
    }

    async scanAndDocument() {
        console.log('üîç Skanowanie i dokumentowanie kodu...');
        
        // Skanuj kod
        await this.codeDocumenter.scanCodebase();
        
        // Dodaj komentarze u≈ºycia
        await this.codeDocumenter.addUsageCommentToAll();
        
        console.log('‚úÖ Skanowanie i dokumentowanie zako≈Ñczone');
    }

    getComprehensiveReport() {
        const errorStats = this.errorTracker.getErrorStats();
        const usageReport = this.codeDocumenter.getUsageReport();
        
        return {
            timestamp: new Date().toISOString(),
            errors: {
                total: errorStats.totalErrors,
                categories: errorStats.categories,
                files: errorStats.files,
                severity: errorStats.severity
            },
            code: {
                totalFunctions: usageReport.totalFunctions,
                unusedFunctions: usageReport.unusedFunctions,
                mostUsedFunctions: usageReport.mostUsedFunctions,
                filesWithMostFunctions: usageReport.filesWithMostFunctions
            },
            stats: this.stats,
            rules: this.rules
        };
    }

    async generateRulesFromErrors() {
        console.log('üìã Generowanie regu≈Ç z b≈Çƒôd√≥w...');
        
        const errorStats = this.errorTracker.getErrorStats();
        
        for (const [category, data] of Object.entries(errorStats.categories)) {
            if (!this.rules[category]) {
                this.rules[category] = {
                    description: this.getRuleDescription(category),
                    prevention: this.getPreventionTips(category),
                    autoFix: this.shouldAutoFix(category),
                    examples: [],
                    fixAttempts: 0,
                    successRate: 0,
                    lastUpdated: new Date().toISOString()
                };
            }
            
            // Dodaj przyk≈Çady b≈Çƒôd√≥w
            const categoryErrors = this.errorTracker.getErrorsByCategory(category);
            this.rules[category].examples = categoryErrors.slice(0, 5).map(error => ({
                message: error.error.message,
                file: error.context.file,
                line: error.context.line,
                timestamp: error.timestamp
            }));
        }
        
        await this.saveRules();
        console.log('‚úÖ Regu≈Çy wygenerowane');
    }

    getRuleDescription(category) {
        const descriptions = {
            'MODULE_NOT_FOUND': 'B≈ÇƒÖd: Nie mo≈ºna znale≈∫ƒá modu≈Çu. Sprawd≈∫ czy pakiet jest zainstalowany.',
            'INVALID_HANDLER': 'B≈ÇƒÖd: Handler nie jest funkcjƒÖ. Sprawd≈∫ czy funkcja jest poprawnie eksportowana.',
            'SYNTAX_ERROR': 'B≈ÇƒÖd sk≈Çadni w kodzie JavaScript.',
            'PERMISSION_ERROR': 'B≈ÇƒÖd uprawnie≈Ñ - brak dostƒôpu do pliku/katalogu.',
            'CONNECTION_ERROR': 'B≈ÇƒÖd po≈ÇƒÖczenia z bazƒÖ danych lub API.',
            'VALIDATION_ERROR': 'B≈ÇƒÖd walidacji danych.',
            'AUTH_ERROR': 'B≈ÇƒÖd autoryzacji/uwierzytelniania.',
            'DATABASE_ERROR': 'B≈ÇƒÖd bazy danych MongoDB.',
            'MEMORY_ERROR': 'B≈ÇƒÖd pamiƒôci - wyciek pamiƒôci lub za ma≈Ço RAM.',
            'TYPE_ERROR': 'B≈ÇƒÖd typu - nieprawid≈Çowy typ danych.',
            'REFERENCE_ERROR': 'B≈ÇƒÖd referencji - zmienna nie jest zdefiniowana.',
            'UNKNOWN_ERROR': 'Nieznany b≈ÇƒÖd - wymaga dalszej analizy.'
        };
        
        return descriptions[category] || 'Brak opisu dla tej kategorii.';
    }

    getPreventionTips(category) {
        const tips = {
            'MODULE_NOT_FOUND': [
                'Zawsze u≈ºywaj npm install po klonowaniu projektu',
                'Sprawd≈∫ czy package.json zawiera wszystkie zale≈ºno≈õci',
                'U≈ºyj npm ci dla czystej instalacji'
            ],
            'INVALID_HANDLER': [
                'Sprawd≈∫ czy funkcja jest poprawnie eksportowana',
                'U≈ºyj console.log() do debugowania import√≥w',
                'Dodaj walidacjƒô przed rejestracjƒÖ tras'
            ],
            'SYNTAX_ERROR': [
                'U≈ºywaj ESLint do sprawdzania sk≈Çadni',
                'Sprawd≈∫ nawiasy, ≈õredniki i cudzys≈Çowy',
                'U≈ºywaj Prettier do formatowania kodu'
            ],
            'PERMISSION_ERROR': [
                'Sprawd≈∫ uprawnienia do plik√≥w/katalog√≥w',
                'U≈ºyj sudo tylko w razie konieczno≈õci',
                'Sprawd≈∫ czy katalog istnieje przed zapisem'
            ],
            'CONNECTION_ERROR': [
                'Sprawd≈∫ po≈ÇƒÖczenie internetowe',
                'Zweryfikuj URL i port',
                'Dodaj retry logic dla po≈ÇƒÖcze≈Ñ'
            ],
            'VALIDATION_ERROR': [
                'Dodaj walidacjƒô po stronie klienta i serwera',
                'U≈ºywaj bibliotek walidacji (Joi, Yup)',
                'Sprawd≈∫ typy danych przed przetwarzaniem'
            ],
            'AUTH_ERROR': [
                'Sprawd≈∫ tokeny JWT',
                'Zweryfikuj uprawnienia u≈ºytkownika',
                'Dodaj middleware autoryzacji'
            ],
            'DATABASE_ERROR': [
                'Sprawd≈∫ po≈ÇƒÖczenie z MongoDB',
                'Zweryfikuj schemat danych',
                'Dodaj obs≈Çugƒô b≈Çƒôd√≥w w zapytaniach'
            ],
            'MEMORY_ERROR': [
                'Monitoruj u≈ºycie pamiƒôci',
                'Zamykaj po≈ÇƒÖczenia i strumienie',
                'U≈ºywaj garbage collection'
            ],
            'TYPE_ERROR': [
                'U≈ºywaj TypeScript',
                'Dodaj sprawdzanie typ√≥w',
                'U≈ºywaj default values'
            ],
            'REFERENCE_ERROR': [
                'Sprawd≈∫ czy zmienne sƒÖ zdefiniowane',
                'U≈ºywaj let/const zamiast var',
                'Dodaj sprawdzanie undefined'
            ],
            'UNKNOWN_ERROR': [
                'Dodaj szczeg√≥≈Çowe logowanie',
                'U≈ºywaj try-catch blok√≥w',
                'Monitoruj aplikacjƒô'
            ]
        };
        
        return tips[category] || ['Brak wskaz√≥wek dla tej kategorii.'];
    }

    shouldAutoFix(category) {
        const autoFixCategories = [
            'INVALID_HANDLER',
            'MODULE_NOT_FOUND',
            'SYNTAX_ERROR'
        ];
        
        return autoFixCategories.includes(category);
    }
}

module.exports = new CodeManager(); 