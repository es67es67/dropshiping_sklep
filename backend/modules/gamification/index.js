const express = require('express');
const router = express.Router();
const User = require('../../models/userModel');
const Badge = require('../../models/badgeModel');
const Achievement = require('../../models/achievementModel');
const eventSystem = require('../../core/eventSystem');

class GamificationModule {
  constructor() {
    this.router = router;
    this.setupRoutes();
    this.setupEvents();
    this.badges = this.initializeBadges();
    this.achievements = this.initializeAchievements();
  }

  setupRoutes() {
    // Pobieranie profilu u≈ºytkownika z statusami
    this.router.get('/profile/:userId', async (req, res) => {
      try {
        const { userId } = req.params;
        
        const user = await User.findById(userId)
          .populate('badges')
          .populate('achievements')
          .populate('location', 'name type');
        
        if (!user) {
          return res.status(404).json({ error: 'U≈ºytkownik nie znaleziony' });
        }
        
        // Oblicz statystyki
        const stats = await this.calculateUserStats(userId);
        
        // Sprawd≈∫ czy u≈ºytkownik awansowa≈Ç
        const levelUp = await this.checkLevelUp(user);
        
        res.json({
          user,
          stats,
          levelUp
        });
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Pobieranie wszystkich odznak
    this.router.get('/badges', async (req, res) => {
      try {
        const badges = await Badge.find().sort({ requiredPoints: 1 });
        res.json(badges);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Pobieranie wszystkich osiƒÖgniƒôƒá
    this.router.get('/achievements', async (req, res) => {
      try {
        const achievements = await Achievement.find().sort({ requiredPoints: 1 });
        res.json(achievements);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Pobieranie statystyk u≈ºytkownika
    this.router.get('/stats', async (req, res) => {
      try {
        const token = req.headers.authorization?.split(' ')[1];
        if (!token) {
          return res.status(401).json({ error: 'Brak tokenu autoryzacji' });
        }

        const jwt = require('jsonwebtoken');
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        const userId = decoded.userId;

        const user = await User.findById(userId);
        if (!user) {
          return res.status(404).json({ error: 'U≈ºytkownik nie znaleziony' });
        }

        const stats = await this.calculateUserStats(userId);
        const nextLevelExp = this.calculateLevel(user.points + 1) > user.level ? 
          this.calculateLevel(user.points + 1) : user.level + 1;

        res.json({
          level: user.level,
          experience: user.points,
          nextLevelExp: nextLevelExp * 100, // Przyk≈Çadowe obliczenie
          achievements: user.achievements?.length || 0,
          totalAchievements: 20,
          badges: user.badges?.length || 0,
          totalBadges: 25,
          orders: stats.orders || 0,
          reviews: stats.reviews || 0,
          daysActive: stats.daysActive || 0,
          shops: stats.shops || 0,
          products: stats.products || 0
        });
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Ranking u≈ºytkownik√≥w
    this.router.get('/leaderboard', async (req, res) => {
      try {
        const { type = 'points', limit = 50 } = req.query;
        
        let sortField = 'points';
        if (type === 'level') sortField = 'level';
        if (type === 'posts') sortField = 'stats.postsCount';
        if (type === 'shops') sortField = 'stats.shopsCount';
        
        const users = await User.find()
          .sort({ [sortField]: -1 })
          .limit(parseInt(limit))
          .select('username firstName lastName level points stats badges')
          .populate('badges', 'name icon');
        
        res.json(users);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Dodawanie punkt√≥w u≈ºytkownikowi
    this.router.post('/points/add', async (req, res) => {
      try {
        const { userId, points, reason } = req.body;
        
        const user = await User.findById(userId);
        if (!user) {
          return res.status(404).json({ error: 'U≈ºytkownik nie znaleziony' });
        }
        
        const oldLevel = user.level;
        user.points += points;
        
        // Sprawd≈∫ czy u≈ºytkownik awansowa≈Ç
        const newLevel = this.calculateLevel(user.points);
        if (newLevel > oldLevel) {
          user.level = newLevel;
          eventSystem.emitUserLevelUp(userId, newLevel);
        }
        
        await user.save();
        
        // Sprawd≈∫ odznaki i osiƒÖgniƒôcia
        await this.checkBadgesAndAchievements(user);
        
        res.json({
          user: {
            _id: user._id,
            username: user.username,
            points: user.points,
            level: user.level
          },
          pointsAdded: points,
          reason,
          levelUp: newLevel > oldLevel ? { from: oldLevel, to: newLevel } : null
        });
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Nadawanie roli u≈ºytkownikowi (admin)
    this.router.post('/roles/assign', async (req, res) => {
      try {
        const { userId, role, assignedBy } = req.body;
        
        const user = await User.findById(userId);
        if (!user) {
          return res.status(404).json({ error: 'U≈ºytkownik nie znaleziony' });
        }
        
        // Sprawd≈∫ czy u≈ºytkownik ma uprawnienia do nadawania r√≥l
        const adminUser = await User.findById(assignedBy);
        if (!adminUser || !adminUser.roles.includes('admin')) {
          return res.status(403).json({ error: 'Brak uprawnie≈Ñ do nadawania r√≥l' });
        }
        
        if (!user.roles.includes(role)) {
          user.roles.push(role);
          await user.save();
        }
        
        res.json({
          user: {
            _id: user._id,
            username: user.username,
            roles: user.roles
          },
          role,
          assignedBy
        });
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Inicjalizacja systemu gamification
    this.router.post('/initialize', async (req, res) => {
      try {
        await this.initializeSystem();
        res.json({ message: 'System gamification zainicjalizowany pomy≈õlnie' });
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });
  }

  setupEvents() {
    // Nas≈Çuchiwanie na eventy systemowe
    eventSystem.onUserLevelUp(async (data) => {
      console.log(`üéâ U≈ºytkownik ${data.userId} awansowa≈Ç na poziom ${data.newLevel}!`);
      // Tutaj mo≈ºna dodaƒá powiadomienia, email, itp.
    });

    eventSystem.onBadgeEarned(async (data) => {
      console.log(`üèÜ U≈ºytkownik ${data.userId} otrzyma≈Ç odznakƒô ${data.badgeId}!`);
    });

    // Nas≈Çuchiwanie na aktywno≈õci u≈ºytkownik√≥w
    eventSystem.on('product:created', async (data) => {
      await this.addPointsForActivity(data.userId, 10, 'Dodanie produktu');
    });

    eventSystem.on('shop:created', async (data) => {
      await this.addPointsForActivity(data.userId, 25, 'Utworzenie sklepu');
    });

    eventSystem.on('message:sent', async (data) => {
      await this.addPointsForActivity(data.senderId, 1, 'Wys≈Çanie wiadomo≈õci');
    });
  }

  async addPointsForActivity(userId, points, reason) {
    try {
      const user = await User.findById(userId);
      if (!user) return;

      const oldLevel = user.level;
      user.points += points;
      
      const newLevel = this.calculateLevel(user.points);
      if (newLevel > oldLevel) {
        user.level = newLevel;
        eventSystem.emitUserLevelUp(userId, newLevel);
      }
      
      await user.save();
      await this.checkBadgesAndAchievements(user);
      
      console.log(`‚ûï ${points} punkt√≥w dla ${user.username} za: ${reason}`);
    } catch (error) {
      console.error('B≈ÇƒÖd dodawania punkt√≥w:', error);
    }
  }

  calculateLevel(points) {
    // Progresywny system poziom√≥w
    if (points < 100) return 1;
    if (points < 300) return 2;
    if (points < 600) return 3;
    if (points < 1000) return 4;
    if (points < 1500) return 5;
    if (points < 2100) return 6;
    if (points < 2800) return 7;
    if (points < 3600) return 8;
    if (points < 4500) return 9;
    if (points < 5500) return 10;
    return Math.floor((points - 5500) / 1000) + 10;
  }

  async calculateUserStats(userId) {
    try {
      // Tutaj mo≈ºna dodaƒá wiƒôcej statystyk
      const user = await User.findById(userId);
      return {
        totalPoints: user.points,
        level: user.level,
        badgesCount: user.badges.length,
        achievementsCount: user.achievements.length,
        rank: await this.getUserRank(userId)
      };
    } catch (error) {
      console.error('B≈ÇƒÖd obliczania statystyk:', error);
      return {};
    }
  }

  async getUserRank(userId) {
    try {
      const user = await User.findById(userId);
      if (!user) return null;
      
      const rank = await User.countDocuments({ points: { $gt: user.points } });
      return rank + 1;
    } catch (error) {
      console.error('B≈ÇƒÖd obliczania rankingu:', error);
      return null;
    }
  }

  async checkLevelUp(user) {
    const newLevel = this.calculateLevel(user.points);
    if (newLevel > user.level) {
      user.level = newLevel;
      await user.save();
      eventSystem.emitUserLevelUp(user._id, newLevel);
      return { from: user.level, to: newLevel };
    }
    return null;
  }

  async checkBadgesAndAchievements(user) {
    try {
      // Sprawd≈∫ odznaki
      const availableBadges = await Badge.find({
        _id: { $nin: user.badges },
        requiredPoints: { $lte: user.points }
      });
      
      for (const badge of availableBadges) {
        user.badges.push(badge._id);
        eventSystem.emitBadgeEarned(user._id, badge._id);
      }
      
      // Sprawd≈∫ osiƒÖgniƒôcia
      const availableAchievements = await Achievement.find({
        _id: { $nin: user.achievements },
        requiredPoints: { $lte: user.points }
      });
      
      for (const achievement of availableAchievements) {
        user.achievements.push(achievement._id);
      }
      
      if (availableBadges.length > 0 || availableAchievements.length > 0) {
        await user.save();
      }
    } catch (error) {
      console.error('B≈ÇƒÖd sprawdzania odznak i osiƒÖgniƒôƒá:', error);
    }
  }

  initializeBadges() {
    return [
      { name: 'Nowicjusz', description: 'Pierwsze kroki w portalu', requiredPoints: 0, icon: 'üå±' },
      { name: 'Aktywny U≈ºytkownik', description: 'Regularna aktywno≈õƒá', requiredPoints: 100, icon: '‚≠ê' },
      { name: 'Tw√≥rca Tre≈õci', description: 'Dodawanie produkt√≥w i post√≥w', requiredPoints: 300, icon: '‚úçÔ∏è' },
      { name: 'Przedsiƒôbiorca', description: 'Utworzenie sklepu', requiredPoints: 500, icon: 'üè™' },
      { name: 'Ekspert Lokalny', description: 'Wysoka aktywno≈õƒá w lokalnej spo≈Çeczno≈õci', requiredPoints: 1000, icon: 'üèÜ' },
      { name: 'Mistrz Portalu', description: 'OsiƒÖgniƒôcie najwy≈ºszego poziomu', requiredPoints: 5000, icon: 'üëë' }
    ];
  }

  initializeAchievements() {
    return [
      { name: 'Pierwszy Post', description: 'Opublikuj pierwszy post', requiredPoints: 50, icon: 'üìù' },
      { name: 'Pierwszy Produkt', description: 'Dodaj pierwszy produkt', requiredPoints: 100, icon: 'üì¶' },
      { name: 'Pierwszy Sklep', description: 'Utw√≥rz pierwszy sklep', requiredPoints: 250, icon: 'üè™' },
      { name: 'Spo≈Çecznik', description: 'Wy≈õlij 100 wiadomo≈õci', requiredPoints: 200, icon: 'üí¨' },
      { name: 'Kolekcjoner', description: 'ZdobƒÖd≈∫ 5 odznak', requiredPoints: 400, icon: 'üéñÔ∏è' }
    ];
  }

  async initializeSystem() {
    try {
      console.log('üéÆ Inicjalizacja systemu gamification...');
      
      // Utw√≥rz odznaki
      for (const badgeData of this.badges) {
        const existingBadge = await Badge.findOne({ name: badgeData.name });
        if (!existingBadge) {
          await Badge.create(badgeData);
        }
      }
      
      // Utw√≥rz osiƒÖgniƒôcia
      for (const achievementData of this.achievements) {
        const existingAchievement = await Achievement.findOne({ name: achievementData.name });
        if (!existingAchievement) {
          await Achievement.create(achievementData);
        }
      }
      
      console.log('‚úÖ System gamification zainicjalizowany');
    } catch (error) {
      console.error('‚ùå B≈ÇƒÖd inicjalizacji systemu gamification:', error);
      throw error;
    }
  }

  async initialize() {
    console.log('üéÆ Inicjalizacja modu≈Çu gamification...');
    await this.initializeSystem();
    return true;
  }

  getRoutes() {
    return this.router;
  }
}

module.exports = new GamificationModule(); 